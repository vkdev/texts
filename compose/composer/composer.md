# Composer

Каждая composable функция неявно получает контекст: объект Composer, и передает его вниз по дереву всем дочерним функциям. Именнро поэтому composable функция может запускаться только из другой composable функции, тк для запуска ей нужен контекст родителя. Это позволяет компилятору получить состояние дерева из любого узла. Имея объект composer **UI функция эмитит свои изменения в процессе композиции.**

Composer делает следущее:
- отслеживает, какие compose функции вызываются
- следит за тем, какие данные использует каждая функция
- определяет, нужно ли повторно вызвать функцию, если эти данные изменились
- управляет эффективными рекомпозициями
- определяет границы рекомпозиций
- управляет состоянием (remember, mutableStateOf)
- обновляет только те части, которые изменились


Объект Composer передается в каждую composable функцию неявно:

kotlin
```
@Composable
fun myFun() {
    ...
}

```
decompiled to Java
```
public static final void myFun(@Nullable Composer $composer, int $changed) {
   ...
}
```